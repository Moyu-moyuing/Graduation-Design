{"remainingRequest":"E:\\wuhanligong-java\\music\\vue-admin-template-master\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\wuhanligong-java\\music\\vue-admin-template-master\\src\\views\\Editor\\Edit.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"E:\\wuhanligong-java\\music\\vue-admin-template-master\\src\\views\\Editor\\Edit.vue","mtime":1654962947870},{"path":"E:\\wuhanligong-java\\music\\vue-admin-template-master\\node_modules\\css-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\wuhanligong-java\\music\\vue-admin-template-master\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":499162500000},{"path":"E:\\wuhanligong-java\\music\\vue-admin-template-master\\node_modules\\postcss-loader\\src\\index.js","mtime":499162500000},{"path":"E:\\wuhanligong-java\\music\\vue-admin-template-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\wuhanligong-java\\music\\vue-admin-template-master\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKICN3ZWJnbCB7CiAgICBoZWlnaHQ6IDUwMHB4OwogIH0KLmFwcC1jb250YWluZXJ7CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDMyZDQzOwp9Cg=="},{"version":3,"sources":["Edit.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqmCA;AACA;AACA;AACA;AACA;AACA","file":"Edit.vue","sourceRoot":"src/views/Editor","sourcesContent":["<template>\n  <div class=\"app-container\">\n    <div>\n        <el-container>\n           <!-- <el-header>Header</el-header> -->\n           <el-container>\n                <el-aside width=\"260px\">\n                       <Widget/>\n                </el-aside>\n\n                <el-main >\n                    <el-scrollbar class=\"Scrollbar\">\n                        <div id=\"webgl\" style=\"position:relative\">\n                        </div>\n                    </el-scrollbar>\n                </el-main>\n                <el-aside width=\"260px\">\n                    <Attribute/>\n                </el-aside>\n            </el-container>\n            <el-footer>\n                <Footer/>\n            </el-footer>\n        </el-container>\n      <!-- <el-row :gutter=\"20\">\n        <el-col :span=\"3\" :xs=\"24\">\n          <el-card style=\"margin-bottom:20px;height: 500px;\">\n\n          </el-card>\n        </el-col>\n        <el-col :span=\"16\" :xs=\"24\">\n            <div id=\"webgl\" style=\"position:relative\">\n\n            </div>\n        </el-col>\n        <el-col :span=\"3\" :xs=\"24\">\n          <el-card style=\"margin-bottom:20px;height: 500px;\">\n\n          </el-card>\n        </el-col>\n      </el-row> -->\n    </div>\n\n\n  </div>\n</template>\n\n<script>\nimport * as THREE from 'three/build/three.module.js'\nimport Stats from '../../store/Stats/stats.min.js'\nimport Widget from '../Editor/Widget/Widget.vue'\nimport Attribute from '../Editor/Attribute/index.vue'\nimport Footer from '../Editor/Footer/index.vue'\nimport {TransformControls} from 'three/examples/jsm/controls/TransformControls'\nimport {DragControls} from 'three/examples/jsm/controls/DragControls'\nimport {TrackballControls} from 'three/examples/jsm/controls/TrackballControls'\nimport {OrbitControls} from 'three/examples/jsm/controls/OrbitControls'\nimport { Color, Group, Object3D} from '../../lib/three.module.js'\nimport {MOUSE} from 'three/src/constants'\nimport {AxesHelper} from 'three/src/helpers/AxesHelper'\nimport {GridHelper} from 'three/src/helpers/GridHelper.js'\nimport {EventManager} from '../../lib/EventManager'\nimport {DirectionalLightHelper} from 'three/src/helpers/DirectionalLightHelper'\nimport { range } from \"../../components/mode/range\";\nimport { node } from \"../../components/mode/node\";\n//初始数据\nlet renderer,camera,scene,geometry,material,mesh,stats,objs;\n//  let container=document.getElementById('webgl');\n   var controls={\n            positionX:0,\n            positionY:0,\n            positionZ:0\n        }\nlet cameraControls;\nlet transformControl;\nlet eventManager;\nlet directionalLight,ambientLight;\nlet id;\n// let mouse;\n// let raycaster;\n/*这里记录一个小bug\n当拖拽物体略过其他物体上时会造成物体全黑\n应该是材质问题使用了法线变换颜色材质，换成正常颜色应该是没有问题\n\n*/\nlet transing=false;\nlet axesHelper,gridHelper,directLightHelper;\nlet cacheobjects;\nexport default {\n    name:'Editor',\n    components:{\n        Widget,\n        Attribute,\n        Footer\n    },\n    data() {\n        return {\n             state:{\n                GridHelper:true,\n                AxesHelper:true,\n                LightHelper:true,\n                PlaneHelper:false,\n                BoxHelper:false,\n                Control:true\n            },\n            configuration:{},\n        }\n    },\n    watch:{\n        'state.GridHelper':{\n            // immediate:true,\n            deep:true,\n            handler(newValue){\n                if(newValue){\n                    this.AddGrid();\n                }else{\n                    this.RemoveGrid();\n                }\n            }\n        },\n         'state.AxesHelper':{\n            // immediate:true,\n            deep:true,\n            handler(newValue){\n                if(newValue){\n                    this.AddAxes();\n                }else{\n                    this.RemoveAxes();\n                }\n            }\n        },\n        'state.LightHelper':{\n            // immediate:true,\n            deep:true,\n            handler(newValue){\n                if(newValue){\n                    this.AddLight();\n                }else{\n                    this.RemoveLight();\n                }\n            }\n        },\n        'state.Control':{\n            // immediate:true,\n            deep:true,\n            handler(newValue){\n                if(newValue){\n                    this.AddControl();\n                }else{\n                    this.RemoveControl();\n                }\n            }\n        }\n    },\n    methods: {\n        initstate(){\n            this.state={\n                GridHelper:true,\n                AxesHelper:true,\n                LightHelper:true,\n                PlaneHelper:false,\n                BoxHelper:false,\n                Control:true\n            };\n        },\n        AddModel(){\n          this.$bus.$off('AddObjects');\n          //防止多次触发bus总线\n            this.$bus.$on('AddObjects',(em,item)=>{\n                if(item.name=='基础几何模型'||item.name=='3D音乐模型'){\n              this.AddElement(em.type);\n          }\n          else{\n              this.LoadElement(em.type);\n          }\n            })\n        },\n        findcurrentObj(){\n            let that=this;\n            //重定向this,好利用总线\n            this.$bus.$on('requestObj',(target)=>{\n                let object=scene.getObjectByProperty('uuid',target.uuid);\n                that.$bus.$emit('responseObj',object);\n            });\n\n        },\n        CheckFromTree(){\n            this.$bus.$on('checkEvent',(target)=>{\n                if(this.state.Control==true){\n                if(!target){\n                    //处理对于传过来是空目标的情况，直接移除控件\n                     transformControl.detach();\n                    scene.remove(transformControl);\n                }\n                else {\n                    if(transformControl.object&&target.uuid!=transformControl.object.uuid){\n                    //如果从场景结构树中得到的物体与目前的不同才进行事件处理\n                    //即更换射线拾取\n\n                    transformControl.detach();\n                    scene.remove(transformControl);\n                    //先删除当前控件对象\n                    scene.traverse(function(obj){\n                        if(obj.uuid==target.uuid){\n                            if(obj.type.indexOf('Helper')==-1){\n                                //如果不是helper\n                               /* 能否直接传uuid进来查然后传出去？\n\n                               需要重构\n                               */\n                                scene.add(transformControl);\n                                transformControl.attach(obj);\n\n\n                            }\n                              else{\n                                  transformControl.detach();\n                                 scene.remove(transformControl);\n\n\n                              }\n                             return;\n                    }\n                    });\n\n                }\n                else if(!transformControl.object){\n                    //如果控件本身不存在那么直接加\n                    scene.traverse(function(obj){\n                        if(obj.uuid==target.uuid){\n                            //同样需要判断是否是helper\n                        if(obj.type.indexOf('Helper')==-1){\n                                //如果不是helper\n\n                                scene.add(transformControl);\n                                transformControl.attach(obj);\n\n\n                            }\n                              else{\n                                  transformControl.detach();\n                                 scene.remove(transformControl);\n\n\n                              }\n                        return;\n                    }\n                    });\n                }\n                }\n                }\n            });\n        },\n        RemoveGrid(){\n            scene.remove(gridHelper);\n            //console.log(scene);\n        },\n        AddGrid(){\n            scene.add(gridHelper);\n        },\n        RemoveAxes(){\n            scene.remove(axesHelper);\n        },\n        AddAxes(){\n            scene.add(axesHelper);\n        },\n        RemoveLight(){\n            scene.remove(directLightHelper);\n        },\n        AddLight(){\n            scene.add(directLightHelper);\n        },\n        RemoveControl(){\n            transformControl.detach();\n            scene.remove(transformControl);\n            let object=null;\n            this.$bus.$emit('getEvent',object);\n        },\n        AddControl(){\n            scene.add(transformControl);\n\n        },\n      AddHelperAndControl(){\n        this.AddAxes();\n        this.AddControl();\n        this.AddGrid();\n        this.AddLight();\n      },\n      RemoveHelperAndControl(){\n        this.RemoveGrid();\n        this.RemoveAxes();\n        this.RemoveLight();\n        this.RemoveControl();\n      },\n        initHelper(){\n            //加坐标轴辅助工具\n            axesHelper=new AxesHelper(500);\n            axesHelper.raycast=()=>{};\n            axesHelper.name=\"坐标轴\";\n            scene.add(axesHelper);\n            gridHelper=new GridHelper(500,40,'rgb(200,200,200)','rgb(100,100,100)');\n            gridHelper.raycast=()=>{};\n            gridHelper.name=\"网格板\";\n            scene.add(gridHelper);\n            //将两个辅助工具raycast射线方法置空使得其禁用变换控件\n            directLightHelper=new DirectionalLightHelper(directionalLight,7);\n            //directLightHelper.raycast=()=>{};\n            directLightHelper.name=\"定向光助手\";\n            directLightHelper.type=\"DirtectionalLightHelper\";\n            scene.add(directLightHelper);\n\n\n\n\n        },\n        initCameraControl(){\n            cameraControls=new OrbitControls(camera,renderer.domElement);\n            cameraControls.enableDamping=true;\n            cameraControls.mouseButtons={\n                LEFT:null,\n                MIDDLE:MOUSE.DOLLY,\n                RIGHT:MOUSE.ROTATE\n                //左键不控制相机\n                //右键控制旋转\n                //中间键控制缩放\n                //ctrl+右键控制相机平移\n            }\n        },\n        getParents(obj){\n          if(obj.parent){\n            if(obj.parent.type==\"Scene\"){\n              return obj;\n            }else{\n              while(obj.parent.type!=\"Scene\"){\n                obj=obj.parent;\n                console.log(obj);\n              }\n              return obj;\n            }\n          }\n        },\n\n        initEventManager(){\n            eventManager=new EventManager(renderer.domElement,scene,camera,objs);\n            eventManager.addEventListener('mousemove',(event)=>{\n                //全局canvas触发拿到物体指针队列\n                if(event.intersection.length){\n                    const object=event.intersection[0].object;\n\n                    if(object==cacheobjects){\n                        //如果当下鼠标还在同一个物体下不触发任何操作\n\n                        return;\n                    }\n                    else if(object!=cacheobjects&&cacheobjects){\n                        //如果当下鼠标从一个物体移动到另一个物体时\n                        //先触发颜色恢复再触发变色\n\n                        cacheobjects.material.color.multiplyScalar(0.5);\n                        //返回原来颜色\n                    }\n\n                    //如果有材质\n                    if(object.material){\n                        object.material.color.multiplyScalar(2);\n                        //变亮\n\n                        cacheobjects=object;\n                    }\n                }else{\n                    //如果鼠标移动到场景空白处恢复\n                    if(cacheobjects){\n                        cacheobjects.material.color.multiplyScalar(0.5);\n\n                        //返回原来颜色\n                    }\n                    cacheobjects=null;\n                }\n            });\n             // //物体拾取事件处理\n            eventManager.addEventListener('click',(event)=>{\n\n                if(transing){\n                    transing=false;\n                    console.log(transing);\n                    return false;\n                }\n                if(event.intersection.length){\n                    const object=event.intersection[0].object;\n                    console.log(event.intersection);\n                    if(object.type==\"TransformControlsPlane\"){\n                        //如果选取到控制器本身直接跳过\n                        transformControl.detach();\n                        scene.remove(transformControl);\n                    }\n                    else{\n                        //选取到物体\n                          if(this.state.Control==true)\n                          {\n                              //只有当Control属性开启时才启用transformControl\n                              //但不影响显示Tree当前点亮\n                            scene.add(transformControl);\n\n                            //transformControl.attach(object.parent instanceof THREE.Group ? object.parent : object);\n                            transformControl.attach(this.getParents(object));\n                        }\n\n                        //let uuid=object.uuid;\n                        // console.log(uuid);\n                        this.$bus.$emit('getEvent',this.getParents(object));\n                    }\n\n                }else{\n                    //当点击到场景空白处时禁用可控件\n                   transformControl.detach();\n                    scene.remove(transformControl);\n                    let object=null;\n                    this.$bus.$emit('getEvent',object);\n                }\n            });\n        },\n        //射线拾取器\n\n     initLight() {\n        directionalLight = new THREE.DirectionalLight(0xffffff); //添加了一个白色的平行光\n        directionalLight.position.set(20, 50, 50); //设置光的方向\n        directionalLight.name=\"平行光\";\n        scene.add(directionalLight); //添加到场景\n        objs.push(directionalLight);\n        ambientLight=new THREE.AmbientLight(0x222222);\n        ambientLight.name=\"全局光\";\n        //添加一个全局环境光\n        scene.add(ambientLight);\n         objs.push(ambientLight);\n    },\n        // initRaycaster(){\n        //     // raycaster=new THREE.Raycaster();\n\n        // },\n        //对象缓存初始化\n        initCache(){\n            cacheobjects=null;\n        },\n        initControl(){\n  //可视化变换控件对象\n        transformControl = new TransformControls( camera,renderer.domElement );\n        transformControl.type=\"TransformControl\";\n        // scene.add( transformControl );//控件对象添加到场景对象\n        transformControl.addEventListener('mouseDown',(event)=>{\n            //加一个参数控制防止点击事件和拖拽事件冲突\n            transing=true;\n            console.log(transing);\n        });\n        //键盘控制可视化变换控件功能\n        document.addEventListener('keyup',(event)=>{\n            if(event.key=='e'){\n                //E键缩放\n                transformControl.mode=\"scale\";\n                return false;\n            }\n            if(event.key=='r'){\n                //R键旋转\n                transformControl.mode=\"rotate\";\n                return false;\n            }\n            if(event.key=='t'){\n                //T键平移\n                transformControl.mode=\"translate\";\n                return false;\n            }\n\n        });\n        },\n        LoadElement(type){\n\n          scene.background = new THREE.CubeTextureLoader().load([\n          require('@/assets/skybox/'+type+'/Left.png'),\n          require('@/assets/skybox/'+type+'/Right.png'),\n          require('@/assets/skybox/'+type+'/Up.png'),\n          require('@/assets/skybox/'+type+'/Down.png'),\n          require('@/assets/skybox/'+type+'/Front.png'),\n          require('@/assets/skybox/'+type+'/Back.png')\n        ]);\n\n        },\n        AddElement(type){\n            if(type=='lonelyPlanet'){\n                this.initBox();\n            }\n            else if(type=='bezierCurve'){\n                this.initCone();\n            }else if(type=='ethereaTone'){\n                this.initCylinder();\n            }else if(type=='electronicMusic'){\n                this.initSphere();\n            }else if(type=='blastSubwoofer'){\n                this.initTorus();\n            }else if(type=='BarModel'){\n                this.initBars();\n                this.sceneChangedEvent();\n            }else if(type=='LineModel'){\n                this.initLine();\n                this.sceneChangedEvent();\n            }\n        },\n        initBox(){\n            var material=new THREE.MeshStandardMaterial();\n            material.color=new Color(0.8,0.2,0.2);\n            var box=new THREE.Mesh(new THREE.BoxGeometry(5,5,5),material);\n            box.position.set(-50, 20, 0);\n            box.name=\"盒子\";\n            scene.add(box);\n            objs.push(box);\n            this.sceneChangedEvent();\n        },\n       initCone(){\n        var material=new THREE.MeshStandardMaterial();\n        material.color=new Color(0.7,0.6,0.6);\n         var cone=new THREE.Mesh(new THREE.ConeGeometry(5,20,32),material);\n          cone.position.set(20, 20, 0);\n          cone.name=\"圆锥\";\n           scene.add(cone);\n           objs.push(cone);\n          this.sceneChangedEvent();\n           //renderer.render(scene,camera);//渲染\n\n\n       },\n       initCylinder(){\n            var material=new THREE.MeshStandardMaterial();\n            material.color=new Color(0.8,0.7,0.2);\n           var cylinder=new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 20, 32),material);\n           cylinder.position.set(50,20,0);\n           cylinder.name=\"圆柱\";\n           scene.add(cylinder);\n           objs.push(cylinder);\n           this.sceneChangedEvent();\n           //renderer.render(scene,camera);//渲染\n\n       },\n       initSphere(){\n           var material=new THREE.MeshStandardMaterial();\n            material.color=new Color(0.2,0.7,0.2);\n          var  sphere=new THREE.Mesh(new THREE.SphereGeometry(5, 32, 32),material);\n           sphere.position.set(-20, -20, 0);\n           sphere.name=\"球\";\n            scene.add(sphere);\n            objs.push(sphere);\n            this.sceneChangedEvent();\n\n\n\n       },\n       initTorus(){\n           var material=new THREE.MeshStandardMaterial();\n            material.color=new Color(0.3,0.1,0.9);\n           var torus =new THREE.Mesh(new THREE.TorusGeometry(10, 3, 16, 100),material);\n            torus.position.set(50, -20, 0);\n            torus.name=\"圆环\";\n            scene.add(torus);\n            objs.push(torus);\n            this.sceneChangedEvent();\n            //renderer.render(scene,camera);//渲染\n\n\n       },\n        init(){\n            this.initRenderer();\n            this.initScene();\n            this.initCamera();\n            this.initLight();\n            this.initMesh();\n            // this.initRaycaster();\n            this.initCache();\n            this.initCameraControl();\n            this.initControl();\n            this.initHelper();\n            this.watchHelper();\n            // this.initMouseEvent();\n            this.initEventManager();\n            this.sendid();\n            this.initStats();\n\n            // initDatGUI();\n            this.sceneChangedEvent();\n            this.animate();\n           // console.log(scene);\n\n        },\n        watchHelper(){\n            let state=this.state;\n             this.$bus.$emit('stateControl',state);\n        },\n        sceneChangedEvent(){\n            //requestAnimationFrame(this.sceneChangedEvent());\n            let scenelist=scene.children;\n            this.$bus.$emit('sceneChanged',scenelist);\n        },\n        //鼠标事务处理（包括点击事件、移动事件）\n        // initMouseEvent(){\n            //给canvas对象进行鼠标坐标转换\n            // mouse=new Vector2();\n            // let domX=0;\n            // let domY=0;\n            // let width=0;\n            // let height=0;\n            // renderer.domElement.addEventListener('mousemove',(event)=>{\n            //     //console.log(event.offsetX,event.offsetY);\n            //     domX=event.offsetX;\n            //     domY=event.offsetY;\n            //     width=renderer.domElement.offsetWidth;\n            //     height=renderer.domElement.offsetHeight;\n            //     mouse.x=domX/width*2-1;\n            //     mouse.y=-domY*2/height+1;\n            //     // console.log(mouse.x,mouse.y);\n            //     raycaster.setFromCamera(mouse,camera);\n            //     //防止控制器被选中\n            //     scene.remove(transformControl);\n            //     const intersection=raycaster.intersectObjects(scene.children,false);\n            //     //把所有有children的屏蔽掉，可以防止对helper进行控制\n            //     scene.add(transformControl);\n            //     if(intersection.length){\n            //         //如果拾取到材质物体\n            //         const object=intersection[0].object;\n            //         //如果当下物体不是上次缓存物体，说明是从不同物体上移到当前物体上触发mouseenter事件\n            //         if(object!=cacheobjects){\n            //             if(cacheobjects){\n            //                 //当鼠标从一个物体移动到另一个物体时，先触发之前缓存物体的mouseleave方法\n            //                 //再触发当前物体的mouseenter方法\n            //                 cacheobjects.dispatchEvent({\n            //             type:'mouseleave'\n            //         });\n            //             }\n            //               object.dispatchEvent({\n            //             type:'mouseenter'\n            //         });\n            //         }//如果相等触发mousemove方法得到物体坐标(鼠标一直在物体上移动)\n            //         else if(object==cacheobjects){\n            //             object.dispatchEvent({\n            //             type:'mousemove'\n            //         });\n            //         }\n            //         cacheobjects=object;\n            //     }else{\n            //         //当鼠标从一个物体移动到射线拾取器拾取不到物体时也会触发之前的物体的mouseleave方法\n            //          if(cacheobjects){\n            //                 //当鼠标从一个物体移动到另一个物体时，先触发之前缓存物体的mouseleave方法\n            //                 //再触发当前物体的mouseenter方法\n            //                 cacheobjects.dispatchEvent({\n            //             type:'mouseleave'\n            //         });\n            //     }\n            //         cacheobjects=null;\n\n\n            //     }\n\n\n            // });\n            // // //物体拾取事件处理\n            // renderer.domElement.addEventListener('click',(event)=>{\n            //     if(transing){\n            //         transing=false;\n            //         return false;\n            //     }\n            //     // raycaster.setFromCamera(mouse,camera);\n            //     // //防止控制器被选中\n            //     // scene.remove(transformControl);\n            //     // const intersection=raycaster.intersectObjects(scene.children,false);\n            //     // //把所有有children的屏蔽掉，可以防止对helper进行控制\n            //     // scene.add(transformControl);\n            //     // if(intersection.length){\n\n\n            //     //     const object=intersection[0].object;\n            //     //     transformControl.attach(object);\n            //     // }else{\n            //     //     //当点击到场景空白处时禁用可控件\n            //     //    transformControl.detach();\n            //     // }\n            // });\n\n        // },\n        initStats(){\n            stats = new Stats();\n             stats.domElement.style.position = 'absolute'; //绝对坐标\n                stats.domElement.style.left = '0px';// (0,0)px,左上角\n                stats.domElement.style.top = '0px';\n            document.getElementById('webgl').appendChild(stats.domElement);\n\n        },\n        updatePosition(){\n            mesh.position.set(controls.positionX,controls.positionY,controls.positionZ);\n        },\n        //初始化渲染器\n        initRenderer(){\n\n\n            renderer=new THREE.WebGLRenderer({antialias:true});//实例化渲染器\n            //抗锯齿开启\n            renderer.setSize(window.innerWidth*0.7,window.innerHeight*0.7);//设置宽高\n            document.getElementById('webgl').appendChild(renderer.domElement);//添加到dom\n        },\n        //初始化场景\n        initScene(){\n\n            scene=new THREE.Scene();//实例化场景\n            objs=[];\n        //      scene.background = new THREE.CubeTextureLoader().load([\n        //   require('@/assets/skybox/Galaxy/Left.png'),\n        //   require('@/assets/skybox/Galaxy/Right.png'),\n        //   require('@/assets/skybox/Galaxy/Up.png'),\n        //   require('@/assets/skybox/Galaxy/Down.png'),\n        //   require('@/assets/skybox/Galaxy/Front.png'),\n        //   require('@/assets/skybox/Galaxy/Back.png')\n        // ]);\n          scene.background=new THREE.Color( 0xDEE6E6 );\n            // this.$bus.$emit('sceneChanged',scene);\n        },\n        //初始化相机\n        initCamera(){\n            camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.1,200)\n            //实例化相机】\n            camera.position.set(0,0,150);\n        },\n        //创建模型\n        initMesh(){\n            // geometry = new THREE.BoxGeometry(5, 5, 5 ); //创建几何体\n            // var material=new THREE.MeshStandardMaterial();\n            // material.color=new Color(0.7,0.2,0.2); //创建材质\n\n            // mesh = new THREE.Mesh( geometry, material ); //创建网格\n            // mesh.name=\"盒子\";\n\n            // scene.add( mesh ); //将网格添加到场景\n\n\n            // this.initCone();\n            // this.initBox();\n            this.initLine();\n            this.initBars();\n\n        },\n\n        initBars(){\n            this.audioBars(25,128);\n        },\n\n        audioBars(radius, countData) {\n      let barGroup = new THREE.Group();\n      let R = radius;\n      let N = countData;\n      for (let i = 0; i < N; i++) {\n        let minGroup = new THREE.Group();\n        let box = new THREE.BoxGeometry(1, 1, 1);\n        let material = new THREE.MeshPhongMaterial({\n          color: 0x00ffff\n        }); // 材质对象\n        let m = i;\n        let mesh = new THREE.Mesh(box, material);\n\n        mesh.position.y = 0.5;\n        minGroup.add(mesh);\n        minGroup.position.set(\n          Math.sin(((m * Math.PI) / N) * 2) * R,\n          Math.cos(((m * Math.PI) / N) * 2) * R,\n          0\n        );\n       minGroup.rotation.z = ((-m * Math.PI) / N) * 2;\n        barGroup.add(minGroup);\n      }\n      barGroup.name=\"音频谱\";\n      barGroup.type=\"BarGroup\";\n      scene.add(barGroup);\n      objs.push(barGroup);\n    },\n/* 这里有个原理，为什么对音频线和音频组进行移动旋转操作后 依然可以根据初始化的音频数据进行重画\n按原理来说应该要重新计算各个线段的坐标值进行重绘，为什么这里导出数据后依然可以利用初始化的\nbarNodes进行一个线段计算重回吧，原因是因为，在编辑器中对一个组对象进行操作时，其各子对象\n的坐标并不会变化，只改变这个组对象的位置、旋转等信息，其子对象的坐标一直是相对于其父对象的\n坐标即本地坐标，而非世界坐标，只有当父对象是scene场景时，本地坐标才等于世界坐标\n */\n        initLine(){\n            this.audioLines(20,256);\n        },\n        renderGeometries(vertices) {\n            const res = [];\n            vertices = vertices.concat(vertices[0]);\n            //合并数组，把里外位置告知要画的线\n            vertices.forEach(value => {\n            res.push(value.x, value.y, 0);\n      });\n            return new THREE.BufferAttribute(new Float32Array(res), 3);\n    },\n        audioLines(radius, countData) {\n            var barNodes = range(0, countData).map(index => {\n                return new node(\n                radius,\n                ((index / countData) * 360 + 45) % 360,\n                new THREE.Vector2(0, 0)\n                );\n            });\n            console.log(barNodes);\n            //得到一个记录圆上256个点的位置信息的数组\n            const lineMaterial = new THREE.LineBasicMaterial({\n                color: 0x00ffff\n            });\n            var barLine = range(0, countData).map(index => {\n            return new THREE.Line(\n                new THREE.BufferGeometry().setAttribute(\n                    \"position\",\n                this.renderGeometries([\n                    barNodes[index].positionA(),\n                     barNodes[index].positionB()\n            ])\n          ),\n            lineMaterial\n            );\n        });\n        var outLine = new THREE.Line(\n        new THREE.BufferGeometry().setAttribute(\n          \"position\",\n          this.renderGeometries(barNodes.map(node => node.positionA()))\n        ),\n        lineMaterial\n      );\n\n      var inLine = new THREE.Line(\n        new THREE.BufferGeometry().setAttribute(\n          \"position\",\n          this.renderGeometries(barNodes.map(node => node.positionB()))\n        ),\n        lineMaterial\n      );\n\n      var linesGroup = new THREE.Group();\n      linesGroup.add(outLine);\n      linesGroup.add(inLine);\n      barLine.forEach(line => linesGroup.add(line));\n      linesGroup.name=\"音频线\";\n      linesGroup.type=\"LineGroup\";\n      scene.add(linesGroup);\n      objs.push(linesGroup);\n    },\n\n\n\n        update(){\n            stats.update();\n        },\n        Reset(){\n\n        },\n        ResetAll(){\n            this.$bus.$on('reset',()=>{\n                this.Reset();\n            });\n        },\n        Export(){\n            let that=this;\n            this.$bus.$on('export',()=>{\n            // if(scene.children.length>0){\n            //     let obj;\n            //     //删除所有helper，只保留光源、材质\n            //     for(var i=scene.children.length-1;i>=0;i--){\n            //\n            //          obj=scene.children[i];\n            //         if(obj.type.indexOf('Helper')!=-1||obj.type.indexOf('Control')!=-1){\n            //              scene.remove(obj);\n            //         }\n            //     }\n            // }\n              that.RemoveHelperAndControl();\n\n                //因为每次迭代中.children 一旦remove后从头开始执行\n                //数组会改变，因此使用遍历的forEach也好，traverse也好数组的\n                //索引全都改变，只会删除一个对象\n                //但如果从后开始遍历删除，每次remove后前面的索引也即是未遍历过的节点索引不会变\n                //使用state值然后进行深度监听依然不行，因为watch方法每次在mounted之后\n                //这就导致了如果mounted中的data值变化，我需要导出的数据还是原来数据，watch只会在之后\n                //发生作用。\n\n            var JSONStr=JSON.stringify(scene.toJSON());\n\n            this.download(\"scene.json\",JSONStr);\n            that.AddHelperAndControl();\n            });\n        },\n        download(filename,text){\n            var pom=document.createElement('a');\n            pom.setAttribute('href','data:text/plain;charset=utf-8,'\n            +encodeURIComponent(text));\n            pom.setAttribute('download',filename);\n            if(document.createEvent){\n                var event=document.createEvent('MouseEvents');\n                event.initMouseEvent('click',true, false,\n                window,0,0,0,0,0,false,false,false,false,0,null);\n                pom.dispatchEvent(event);\n            }else{\n                pom.click();\n            }\n\n        },\n        //运行动画\n        animate(){\n            id=requestAnimationFrame(this.animate);//循环调用函数\n\n            // mesh.rotation.x+=0.01;\n            // // //每帧网格模型沿x轴旋转0.01弧度\n            // mesh.rotation.y+=0.02;\n            // //每帧网格模型沿y轴旋转0.02弧度\n            // //stats.update();//更新性能检测框\n\n            this.update();\n            renderer.render(scene,camera);//渲染\n        },\n      sendres(){\n          this.$bus.$on('sendres',(res)=>{\n           var loader=new THREE.ObjectLoader();\n           loader.parse(res,function (obj){\n             scene=obj;\n\n           })\n          })\n      },\n      requestsave(){\n          let that=this;\n        this.$bus.$on('requestsave',()=>{\n          // if(scene.children.length>0){\n          //   let obj;\n          //   //删除所有helper，只保留光源、材质\n          //   for(var i=scene.children.length-1;i>=0;i--){\n          //\n          //     obj=scene.children[i];\n          //     if(obj.type.indexOf('Helper')!=-1||obj.type.indexOf('Control')!=-1){\n          //       scene.remove(obj);\n          //     }\n          //   }\n          // }\n          that.RemoveHelperAndControl();\n          var JSONStr=JSON.stringify(scene.toJSON());\n          let file=new File([JSONStr],'scene.json',{\n            type: 'application/json',\n            lastModified: Date.now()\n          });\n          //组合成文件\n          let param=new FormData();\n          param.append('file',file);\n          let config={headers:{'Content-Type':'multipart/form-data'}}\n          this.request.post(\"http://localhost:9090/upload\",\n            param,config).then(res=>{\n            // console.log(res);\n            that.$bus.$emit('responsesave',res.fileid);\n            console.log(res.fileid);\n            console.log(scene);\n            that.AddHelperAndControl();\n          });\n          //提交表单文件返回id\n\n\n        });\n      },\n      sendid(){\n        let id=null;\n        this.$bus.$emit('sendfileid',id);\n      },\n      startedit(){\n\n          let that=this;\n        this.$bus.$on('eidtfile',(res,id)=>{\n          //objs=[];\n          //因为每次跳转路由都会重新初始化其他工具，这里先删除\n          //把json数据打包成文件通过url进行传输\n          var JSONStr=JSON.stringify(res);\n          let file=new File([JSONStr],'scene.json',{\n            type: 'application/json',\n            lastModified: Date.now()\n          });\n          //组合成文件\n          let url = null ;\n          if (window.createObjectURL!=undefined) { // basic\n            url = window.createObjectURL(file) ;\n          } else if (window.URL!=undefined) { // mozilla(firefox)\n            url = window.URL.createObjectURL(file) ;\n          } else if (window.webkitURL!=undefined) { // webkit or chrome\n            url = window.webkitURL.createObjectURL(file) ;\n          }\n\n\n          //that.RemoveHelperAndControl();\n          var loader=new THREE.ObjectLoader();\n          loader.load(url,\n            function(obj){\n             //let newobjs=[];\n            that.RemoveHelperAndControl();\n            scene=obj;\n            that.AddHelperAndControl();\n              // if(obj.children.length>0){\n              //   let childobj;\n              //   for(var i=obj.children.length-1;i>=0;i--){\n              //     childobj=obj.children[i];\n              //     if(childobj.type.indexOf('Object3D')!=-1||childobj.type.indexOf('Mesh')!=-1){\n              //       newobjs.push(childobj);\n              //     }\n              //     if((childobj.type.indexOf('Light')!=-1&&childobj.type.indexOf('Helper')==-1)){\n              //       newobjs.push(childobj);\n              //     }\n              //   }\n              // }\n              // objs=newobjs;\n              // console.log(objs);\n\n\n              // if(scene.children.length>0){\n              //   let childobj;\n              //   //删除所有可操作对象\n              //   for(var i=scene.children.length-1;i>=0;i--){\n              //     childobj=scene.children[i];\n              //     if((childobj.type.indexOf('Light')!=-1&&childobj.type.indexOf('Helper')==-1)||childobj.type.indexOf('Group')!=-1||childobj.type.indexOf('Mesh')!=-1){\n              //       scene.remove(childobj);\n              //\n              //     }\n              //\n              //   } console.log(scene);\n                //console.log(objs);\n              // }\n              //加载完成后进行\n              // scene.background=obj.background;\n              // if(obj.children.length>0) {\n              //   let childobj;\n              //   for (var i = obj.children.length - 1; i >= 0; i--) {\n              //     childobj = obj.children[i];\n              //     obj.remove(childobj);\n              //     childobj.parent=scene;\n              //     scene.add(childobj);\n              //     objs.push(childobj);\n              //   }\n              // }\n              eventManager.RemoveEvent();\n             that.initEventManager();\n              that.sceneChangedEvent();\n              //console.log(objs);\n            },\n            // onProgress callback\n            function ( xhr ) {\n              console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );\n            },\n\n            // onError callback\n            function ( err ) {\n              console.error( 'An error happened'+err );\n            });\n          // loader.parse(res,function (obj){\n          //\n          //  }\n          //  console.log(scene);\n            //console.log(scene);\n           //  that.AddHelperAndControl();\n           //  //需要初始化一下objs\n           //  if(scene.children.length>0){\n           //    let obj;\n           //    //删除所有helper，只保留光源、材质\n           //    objs=[];\n           //    //初始化一下\n           //    for(var i=scene.children.length-1;i>=0;i--){\n           //\n           //      obj=scene.children[i];\n           //      if(obj.type.indexOf('Mesh')!=-1){\n           //        //说明是需要操作的物体\n           //        objs.push(obj);\n           //      }\n           //      if(obj.type.indexOf('Object3D')!=-1){\n           //        objs.push(obj);\n           //      }\n           //      // if(obj.type.indexOf('Light')!=-1&&obj.type.indexOf('Helper')==-1){\n           //      //   objs.push(obj);\n           //      // }\n           //    }\n           //    console.log(objs);\n           //  }\n           //  transing=false;\n           //\n           // // that.initEventManager();\n          //    that.sceneChangedEvent();\n          //\n          // });\n          that.$bus.$emit('sendfileid',id);\n\n        });\n      },\n      addnew(){\n          let that=this;\n          this.$bus.$off('addfile');\n        this.$bus.$on('addfile',()=>{\n          let id=null;\n          that.$bus.$emit('sendfileid',id);\n          //设置个时间防止 加载问题\n\n          that.RemoveHelperAndControl();\n          that.initScene();\n          that.initLight();\n          that.initMesh();\n          that.AddHelperAndControl();\n          eventManager.RemoveEvent();\n          that.initEventManager();\n          that.sceneChangedEvent();\n        });\n      }\n    },\n\n  mounted() {\n        this.init();\n        this.CheckFromTree();\n        this.findcurrentObj();\n        this.AddModel();\n        this.ResetAll();\n        this.Export();\n        this.sendres();\n        this.requestsave();\n        this.startedit();\n        this.addnew();\n    },\n}\n</script>\n<style>\n #webgl {\n    height: 500px;\n  }\n.app-container{\n    background-color: #432d43;\n}\n</style>\n"]}]}