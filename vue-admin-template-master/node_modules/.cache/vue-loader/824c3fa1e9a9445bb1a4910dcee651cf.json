{"remainingRequest":"E:\\vue\\vue-admin-template-master\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\vue\\vue-admin-template-master\\src\\views\\Editor\\Edit.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"E:\\vue\\vue-admin-template-master\\src\\views\\Editor\\Edit.vue","mtime":1651916305979},{"path":"E:\\vue\\vue-admin-template-master\\node_modules\\css-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\vue\\vue-admin-template-master\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":499162500000},{"path":"E:\\vue\\vue-admin-template-master\\node_modules\\postcss-loader\\src\\index.js","mtime":499162500000},{"path":"E:\\vue\\vue-admin-template-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\vue\\vue-admin-template-master\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKICN3ZWJnbCB7CiAgICBoZWlnaHQ6IDUwMHB4OwogIH0KLmFwcC1jb250YWluZXJ7CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDMyZDQzOwp9Cg=="},{"version":3,"sources":["Edit.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA04BA;AACA;AACA;AACA;AACA;AACA","file":"Edit.vue","sourceRoot":"src/views/Editor","sourcesContent":["<template>\r\n  <div class=\"app-container\">\r\n    <div>\r\n        <el-container>\r\n           <!-- <el-header>Header</el-header> -->\r\n           <el-container>\r\n                <el-aside width=\"260px\">\r\n                       <Widget/>\r\n                </el-aside>\r\n                \r\n                <el-main >\r\n                    <el-scrollbar class=\"Scrollbar\">\r\n                        <div id=\"webgl\" style=\"position:relative\">\r\n                        </div>\r\n                    </el-scrollbar>\r\n                </el-main>\r\n                <el-aside width=\"260px\">\r\n                    <Attribute/>\r\n                </el-aside>\r\n            </el-container>\r\n            <el-footer>\r\n                <Footer/>\r\n            </el-footer>\r\n        </el-container>\r\n      <!-- <el-row :gutter=\"20\">\r\n        <el-col :span=\"3\" :xs=\"24\">\r\n          <el-card style=\"margin-bottom:20px;height: 500px;\">  \r\n              \r\n          </el-card>\r\n        </el-col>\r\n        <el-col :span=\"16\" :xs=\"24\">\r\n            <div id=\"webgl\" style=\"position:relative\">\r\n               \r\n            </div>\r\n        </el-col>\r\n        <el-col :span=\"3\" :xs=\"24\">\r\n          <el-card style=\"margin-bottom:20px;height: 500px;\">  \r\n              \r\n          </el-card>\r\n        </el-col>\r\n      </el-row> -->\r\n    </div>\r\n\r\n                \r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport * as THREE from 'three/build/three.module.js'\r\nimport Stats from '../../store/Stats/stats.min.js'\r\nimport Widget from '../Editor/Widget/Widget.vue'\r\nimport Attribute from '../Editor/Attribute/index.vue'\r\nimport Footer from '../Editor/Footer/index.vue'\r\nimport {TransformControls} from 'three/examples/jsm/controls/TransformControls'\r\nimport {DragControls} from 'three/examples/jsm/controls/DragControls'\r\nimport {TrackballControls} from 'three/examples/jsm/controls/TrackballControls'\r\nimport {OrbitControls} from 'three/examples/jsm/controls/OrbitControls'\r\nimport { Color, Group, Object3D} from '../../lib/three.module.js'\r\nimport {MOUSE} from 'three/src/constants'\r\nimport {AxesHelper} from 'three/src/helpers/AxesHelper'\r\nimport {GridHelper} from 'three/src/helpers/GridHelper.js'\r\nimport {EventManager} from '../../lib/EventManager'\r\nimport {DirectionalLightHelper} from 'three/src/helpers/DirectionalLightHelper'\r\nimport { range } from \"../../components/mode/range\";\r\nimport { node } from \"../../components/mode/node\";\r\n//初始数据\r\nlet renderer,camera,scene,geometry,material,mesh,stats,objs;\r\n//  let container=document.getElementById('webgl');\r\n   var controls={\r\n            positionX:0,\r\n            positionY:0,\r\n            positionZ:0\r\n        }\r\nlet cameraControls;\r\nlet transformControl;\r\nlet eventManager;\r\nlet directionalLight,ambientLight;\r\n// let mouse;\r\n// let raycaster;\r\n/*这里记录一个小bug\r\n当拖拽物体略过其他物体上时会造成物体全黑\r\n应该是材质问题使用了法线变换颜色材质，换成正常颜色应该是没有问题\r\n\r\n*/\r\nlet transing=false;\r\nlet axesHelper,gridHelper,directLightHelper;\r\nlet cacheobjects;\r\nexport default {\r\n    name:'Editor',\r\n    components:{\r\n        Widget,\r\n        Attribute,\r\n        Footer\r\n    },\r\n    data() {\r\n        return {\r\n             state:{\r\n                GridHelper:true,\r\n                AxesHelper:true,\r\n                LightHelper:true,\r\n                PlaneHelper:false,\r\n                BoxHelper:false,\r\n                Control:true\r\n            },\r\n            configuration:{},\r\n        }\r\n    },\r\n    watch:{\r\n        'state.GridHelper':{\r\n            // immediate:true,\r\n            deep:true,\r\n            handler(newValue){\r\n                if(newValue){\r\n                    this.AddGrid();\r\n                }else{\r\n                    this.RemoveGrid();\r\n                }\r\n            }\r\n        },\r\n         'state.AxesHelper':{\r\n            // immediate:true,\r\n            deep:true,\r\n            handler(newValue){\r\n                if(newValue){\r\n                    this.AddAxes();\r\n                }else{\r\n                    this.RemoveAxes();\r\n                }\r\n            }\r\n        },\r\n        'state.LightHelper':{\r\n            // immediate:true,\r\n            deep:true,\r\n            handler(newValue){\r\n                if(newValue){\r\n                    this.AddLight();\r\n                }else{\r\n                    this.RemoveLight();\r\n                }\r\n            }\r\n        },\r\n        'state.Control':{\r\n            // immediate:true,\r\n            deep:true,\r\n            handler(newValue){\r\n                if(newValue){\r\n                    this.AddControl();\r\n                }else{\r\n                    this.RemoveControl();\r\n                }\r\n            }\r\n        }\r\n    },\r\n    methods: {\r\n        initstate(){\r\n            this.state={\r\n                GridHelper:true,\r\n                AxesHelper:true,\r\n                LightHelper:true,\r\n                PlaneHelper:false,\r\n                BoxHelper:false,\r\n                Control:true\r\n            };\r\n        },\r\n        AddModel(){\r\n            this.$bus.$on('AddObjects',(em,item)=>{\r\n                if(item.name=='2D模型'||item.name=='3D模型'){\r\n              this.AddElement(em.type);\r\n          }\r\n          else{\r\n              this.LoadElement(em.type);\r\n          }\r\n            })\r\n        },\r\n        findcurrentObj(){ \r\n            let that=this;\r\n            //重定向this,好利用总线\r\n            this.$bus.$on('requestObj',(target)=>{\r\n                let object=scene.getObjectByProperty('uuid',target.uuid);\r\n                that.$bus.$emit('responseObj',object);\r\n            });\r\n            \r\n        },\r\n        CheckFromTree(){\r\n            this.$bus.$on('checkEvent',(target)=>{\r\n                if(this.state.Control==true){\r\n                if(!target){\r\n                    //处理对于传过来是空目标的情况，直接移除控件\r\n                     transformControl.detach();\r\n                    scene.remove(transformControl);\r\n                }\r\n                else {\r\n                    if(transformControl.object&&target.uuid!=transformControl.object.uuid){\r\n                    //如果从场景结构树中得到的物体与目前的不同才进行事件处理\r\n                    //即更换射线拾取\r\n                    \r\n                    transformControl.detach();\r\n                    scene.remove(transformControl);\r\n                    //先删除当前控件对象\r\n                    scene.traverse(function(obj){\r\n                        if(obj.uuid==target.uuid){\r\n                            if(obj.type.indexOf('Helper')==-1){\r\n                                //如果不是helper\r\n                               /* 能否直接传uuid进来查然后传出去？\r\n                               \r\n                               需要重构\r\n                               */\r\n                                scene.add(transformControl);\r\n                                transformControl.attach(obj);\r\n                                \r\n                                \r\n                            }\r\n                              else{\r\n                                  transformControl.detach();\r\n                                 scene.remove(transformControl);\r\n                                 \r\n                               \r\n                              }  \r\n                             return; \r\n                    }\r\n                    });\r\n\r\n                }\r\n                else if(!transformControl.object){\r\n                    //如果控件本身不存在那么直接加\r\n                    scene.traverse(function(obj){\r\n                        if(obj.uuid==target.uuid){\r\n                            //同样需要判断是否是helper\r\n                        if(obj.type.indexOf('Helper')==-1){\r\n                                //如果不是helper\r\n                               \r\n                                scene.add(transformControl);\r\n                                transformControl.attach(obj);\r\n                                \r\n                                \r\n                            }\r\n                              else{\r\n                                  transformControl.detach();\r\n                                 scene.remove(transformControl);\r\n                                \r\n                               \r\n                              }  \r\n                        return;\r\n                    }\r\n                    });\r\n                }\r\n                }\r\n                }\r\n            });\r\n        },\r\n        RemoveGrid(){\r\n            scene.remove(gridHelper);\r\n            //console.log(scene);\r\n        },\r\n        AddGrid(){\r\n            scene.add(gridHelper);\r\n        },\r\n        RemoveAxes(){\r\n            scene.remove(axesHelper);\r\n        },\r\n        AddAxes(){\r\n            scene.add(axesHelper);\r\n        },\r\n        RemoveLight(){\r\n            scene.remove(directLightHelper);\r\n        },\r\n        AddLight(){\r\n            scene.add(directLightHelper);\r\n        },\r\n        RemoveControl(){\r\n            transformControl.detach();\r\n            scene.remove(transformControl);\r\n            let object=null;\r\n            this.$bus.$emit('getEvent',object);\r\n        },\r\n        AddControl(){\r\n            scene.add(transformControl);\r\n\r\n        },\r\n        initHelper(){\r\n            //加坐标轴辅助工具\r\n            axesHelper=new AxesHelper(500);\r\n            axesHelper.raycast=()=>{};\r\n            axesHelper.name=\"坐标轴\";\r\n            scene.add(axesHelper);\r\n            gridHelper=new GridHelper(500,40,'rgb(200,200,200)','rgb(100,100,100)');\r\n            gridHelper.raycast=()=>{};\r\n            gridHelper.name=\"网格板\";\r\n            scene.add(gridHelper);\r\n            //将两个辅助工具raycast射线方法置空使得其禁用变换控件\r\n            directLightHelper=new DirectionalLightHelper(directionalLight,7);\r\n            //directLightHelper.raycast=()=>{};\r\n            directLightHelper.name=\"定向光助手\";\r\n            directLightHelper.type=\"DirtectionalLightHelper\";\r\n            scene.add(directLightHelper);\r\n            \r\n\r\n\r\n\r\n        },\r\n        initCameraControl(){\r\n            cameraControls=new OrbitControls(camera,renderer.domElement);\r\n            cameraControls.enableDamping=true;\r\n            cameraControls.mouseButtons={\r\n                LEFT:null,\r\n                MIDDLE:MOUSE.DOLLY,\r\n                RIGHT:MOUSE.ROTATE\r\n                //左键不控制相机\r\n                //右键控制旋转\r\n                //中间键控制缩放\r\n                //ctrl+右键控制相机平移\r\n            }\r\n        },\r\n        getParents(obj){\r\n            if(obj.parent==scene){\r\n                return obj;\r\n            }else{\r\n                while(obj.parent!=scene){\r\n                    obj=obj.parent;\r\n                }\r\n                return obj;\r\n            }\r\n            \r\n        },\r\n        initEventManager(){\r\n            eventManager=new EventManager(renderer.domElement,scene,camera,objs);\r\n            eventManager.addEventListener('mousemove',(event)=>{\r\n                //全局canvas触发拿到物体指针队列\r\n                if(event.intersection.length){\r\n                    const object=event.intersection[0].object;\r\n                   \r\n                    if(object==cacheobjects){\r\n                        //如果当下鼠标还在同一个物体下不触发任何操作\r\n                        \r\n                        return;\r\n                    }\r\n                    else if(object!=cacheobjects&&cacheobjects){\r\n                        //如果当下鼠标从一个物体移动到另一个物体时\r\n                        //先触发颜色恢复再触发变色\r\n                        \r\n                        cacheobjects.material.color.multiplyScalar(0.5);\r\n                        //返回原来颜色\r\n                    }\r\n\r\n                    //如果有材质\r\n                    if(object.material){\r\n                        object.material.color.multiplyScalar(2);\r\n                        //变亮\r\n                        \r\n                        cacheobjects=object;\r\n                    }\r\n                }else{\r\n                    //如果鼠标移动到场景空白处恢复\r\n                    if(cacheobjects){\r\n                        cacheobjects.material.color.multiplyScalar(0.5);\r\n                       \r\n                        //返回原来颜色\r\n                    }\r\n                    cacheobjects=null;\r\n                }\r\n            });\r\n             // //物体拾取事件处理\r\n            eventManager.addEventListener('click',(event)=>{\r\n              \r\n                if(transing){\r\n                    transing=false;\r\n                    return false;\r\n                }\r\n                if(event.intersection.length){\r\n                    const object=event.intersection[0].object;\r\n                    console.log(event.intersection);\r\n                    if(object.type==\"TransformControlsPlane\"){\r\n                        //如果选取到控制器本身直接跳过\r\n                        transformControl.detach();\r\n                        scene.remove(transformControl);\r\n                    }\r\n                    else{\r\n                        //选取到物体\r\n                          if(this.state.Control==true)\r\n                          {\r\n                              //只有当Control属性开启时才启用transformControl\r\n                              //但不影响显示Tree当前点亮\r\n                            scene.add(transformControl);\r\n                            \r\n                            //transformControl.attach(object.parent instanceof THREE.Group ? object.parent : object);\r\n                            transformControl.attach(this.getParents(object));\r\n                        }\r\n                        \r\n                        //let uuid=object.uuid;\r\n                        // console.log(uuid);\r\n                        this.$bus.$emit('getEvent',this.getParents(object));\r\n                    }\r\n                    \r\n                }else{\r\n                    //当点击到场景空白处时禁用可控件\r\n                   transformControl.detach();\r\n                    scene.remove(transformControl);\r\n                    let object=null;\r\n                    this.$bus.$emit('getEvent',object);\r\n                }\r\n            });\r\n        },\r\n        //射线拾取器\r\n        \r\n     initLight() {\r\n        directionalLight = new THREE.DirectionalLight(0xffffff); //添加了一个白色的平行光\r\n        directionalLight.position.set(20, 50, 50); //设置光的方向\r\n        directionalLight.name=\"平行光\";\r\n        scene.add(directionalLight); //添加到场景\r\n        objs.push(directionalLight);\r\n        ambientLight=new THREE.AmbientLight(0x222222);\r\n        ambientLight.name=\"全局光\";\r\n        //添加一个全局环境光\r\n        scene.add(ambientLight);\r\n         objs.push(ambientLight);\r\n    },\r\n        // initRaycaster(){\r\n        //     // raycaster=new THREE.Raycaster();\r\n\r\n        // },\r\n        //对象缓存初始化\r\n        initCache(){\r\n            cacheobjects=null;\r\n        },\r\n        initControl(){\r\n  //可视化变换控件对象\r\n        transformControl = new TransformControls( camera,renderer.domElement );\r\n        transformControl.type=\"TransformControl\";\r\n        // scene.add( transformControl );//控件对象添加到场景对象\r\n        transformControl.addEventListener('mouseDown',(event)=>{\r\n            //加一个参数控制防止点击事件和拖拽事件冲突\r\n            transing=true;\r\n        });\r\n        //键盘控制可视化变换控件功能\r\n        document.addEventListener('keyup',(event)=>{\r\n            if(event.key=='e'){\r\n                //E键缩放\r\n                transformControl.mode=\"scale\";\r\n                return false;\r\n            }\r\n            if(event.key=='r'){\r\n                //R键旋转\r\n                transformControl.mode=\"rotate\";\r\n                return false;\r\n            }\r\n            if(event.key=='t'){\r\n                //T键平移\r\n                transformControl.mode=\"translate\";\r\n                return false;\r\n            }\r\n            \r\n        });\r\n        },\r\n        LoadElement(type){\r\n            if(type=='model-1'){\r\n                this.initLine();\r\n                this.sceneChangedEvent();\r\n            }\r\n            else if(type=='model-2'){\r\n                this.initBars();\r\n                this.sceneChangedEvent();\r\n            }\r\n             else if(type=='model-3'){\r\n               scene.background = new THREE.CubeTextureLoader().load([\r\n          require('@/assets/skybox/BlueRed/Left.png'),\r\n          require('@/assets/skybox/BlueRed/Right.png'),\r\n          require('@/assets/skybox/BlueRed/Up.png'),\r\n          require('@/assets/skybox/BlueRed/Down.png'),\r\n          require('@/assets/skybox/BlueRed/Front.png'),\r\n          require('@/assets/skybox/BlueRed/Back.png')\r\n        ]);\r\n            }\r\n        },\r\n        AddElement(type){\r\n            if(type=='lonelyPlanet'){\r\n                this.initBox();\r\n            }\r\n            else if(type=='bezierCurve'){\r\n                this.initCone();\r\n            }else if(type=='ethereaTone'){\r\n                this.initCylinder();\r\n            }else if(type=='electronicMusic'){\r\n                this.initSphere();\r\n            }else if(type=='blastSubwoofer'){\r\n                this.initTorus();\r\n            }\r\n\r\n        },\r\n        initBox(){\r\n            var material=new THREE.MeshStandardMaterial();\r\n            material.color=new Color(0.8,0.2,0.2);\r\n            var box=new THREE.Mesh(new THREE.BoxGeometry(5,5,5),material);\r\n            box.position.set(-50, 20, 0);\r\n            box.name=\"盒子\";\r\n            scene.add(box);\r\n            objs.push(box);\r\n            this.sceneChangedEvent();\r\n        },\r\n       initCone(){\r\n        var material=new THREE.MeshStandardMaterial();\r\n        material.color=new Color(0.7,0.6,0.6);\r\n         var cone=new THREE.Mesh(new THREE.ConeGeometry(5,20,32),material);\r\n          cone.position.set(20, 20, 0);\r\n          cone.name=\"圆锥\";\r\n           scene.add(cone);\r\n           objs.push(cone);\r\n          this.sceneChangedEvent();\r\n           //renderer.render(scene,camera);//渲染\r\n          \r\n            \r\n       },\r\n       initCylinder(){\r\n            var material=new THREE.MeshStandardMaterial();\r\n            material.color=new Color(0.8,0.7,0.2);\r\n           var cylinder=new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 20, 32),material);\r\n           cylinder.position.set(50,20,0);\r\n           cylinder.name=\"圆柱\";\r\n           scene.add(cylinder);\r\n           objs.push(cylinder);\r\n           this.sceneChangedEvent();\r\n           //renderer.render(scene,camera);//渲染\r\n           \r\n       },\r\n       initSphere(){\r\n           var material=new THREE.MeshStandardMaterial();\r\n            material.color=new Color(0.2,0.7,0.2);\r\n          var  sphere=new THREE.Mesh(new THREE.SphereGeometry(5, 32, 32),material);\r\n           sphere.position.set(-20, -20, 0);\r\n           sphere.name=\"球\";\r\n            scene.add(sphere);\r\n            objs.push(sphere);\r\n            this.sceneChangedEvent();\r\n           \r\n            \r\n            \r\n       },\r\n       initTorus(){\r\n           var material=new THREE.MeshStandardMaterial();\r\n            material.color=new Color(0.3,0.1,0.9);\r\n           var torus =new THREE.Mesh(new THREE.TorusGeometry(10, 3, 16, 100),material);\r\n            torus.position.set(50, -20, 0);\r\n            torus.name=\"圆环\";\r\n            scene.add(torus);\r\n            objs.push(torus);\r\n            this.sceneChangedEvent();\r\n            //renderer.render(scene,camera);//渲染\r\n            \r\n           \r\n       },\r\n        init(){\r\n            this.initRenderer();\r\n            this.initScene();\r\n            this.initCamera();\r\n            this.initLight();\r\n            this.initMesh();\r\n            // this.initRaycaster();\r\n            this.initCache();\r\n            this.initCameraControl();\r\n            this.initControl();\r\n            this.initHelper();\r\n            this.watchHelper();\r\n            // this.initMouseEvent();\r\n            this.initEventManager();\r\n            this.initStats();\r\n            \r\n            // initDatGUI();\r\n            this.sceneChangedEvent();\r\n            this.animate();\r\n            console.log(scene);\r\n            \r\n        },\r\n        watchHelper(){\r\n            let state=this.state;\r\n             this.$bus.$emit('stateControl',state);\r\n        },\r\n        sceneChangedEvent(){\r\n            let scenelist=scene.children;\r\n            this.$bus.$emit('sceneChanged',scenelist);\r\n        },\r\n        //鼠标事务处理（包括点击事件、移动事件）\r\n        // initMouseEvent(){\r\n            //给canvas对象进行鼠标坐标转换\r\n            // mouse=new Vector2();\r\n            // let domX=0;\r\n            // let domY=0;\r\n            // let width=0;\r\n            // let height=0;\r\n            // renderer.domElement.addEventListener('mousemove',(event)=>{\r\n            //     //console.log(event.offsetX,event.offsetY);\r\n            //     domX=event.offsetX;\r\n            //     domY=event.offsetY;\r\n            //     width=renderer.domElement.offsetWidth;\r\n            //     height=renderer.domElement.offsetHeight;\r\n            //     mouse.x=domX/width*2-1;\r\n            //     mouse.y=-domY*2/height+1;\r\n            //     // console.log(mouse.x,mouse.y);\r\n            //     raycaster.setFromCamera(mouse,camera);\r\n            //     //防止控制器被选中\r\n            //     scene.remove(transformControl);\r\n            //     const intersection=raycaster.intersectObjects(scene.children,false);\r\n            //     //把所有有children的屏蔽掉，可以防止对helper进行控制\r\n            //     scene.add(transformControl);\r\n            //     if(intersection.length){\r\n            //         //如果拾取到材质物体\r\n            //         const object=intersection[0].object;\r\n            //         //如果当下物体不是上次缓存物体，说明是从不同物体上移到当前物体上触发mouseenter事件\r\n            //         if(object!=cacheobjects){\r\n            //             if(cacheobjects){\r\n            //                 //当鼠标从一个物体移动到另一个物体时，先触发之前缓存物体的mouseleave方法\r\n            //                 //再触发当前物体的mouseenter方法\r\n            //                 cacheobjects.dispatchEvent({\r\n            //             type:'mouseleave'\r\n            //         });\r\n            //             }\r\n            //               object.dispatchEvent({\r\n            //             type:'mouseenter'\r\n            //         });\r\n            //         }//如果相等触发mousemove方法得到物体坐标(鼠标一直在物体上移动)\r\n            //         else if(object==cacheobjects){\r\n            //             object.dispatchEvent({\r\n            //             type:'mousemove'\r\n            //         });\r\n            //         }\r\n            //         cacheobjects=object;\r\n            //     }else{\r\n            //         //当鼠标从一个物体移动到射线拾取器拾取不到物体时也会触发之前的物体的mouseleave方法\r\n            //          if(cacheobjects){\r\n            //                 //当鼠标从一个物体移动到另一个物体时，先触发之前缓存物体的mouseleave方法\r\n            //                 //再触发当前物体的mouseenter方法\r\n            //                 cacheobjects.dispatchEvent({\r\n            //             type:'mouseleave'\r\n            //         });\r\n            //     }\r\n            //         cacheobjects=null;\r\n\r\n\r\n            //     }\r\n                \r\n               \r\n            // });\r\n            // // //物体拾取事件处理\r\n            // renderer.domElement.addEventListener('click',(event)=>{\r\n            //     if(transing){\r\n            //         transing=false;\r\n            //         return false;\r\n            //     }\r\n            //     // raycaster.setFromCamera(mouse,camera);\r\n            //     // //防止控制器被选中\r\n            //     // scene.remove(transformControl);\r\n            //     // const intersection=raycaster.intersectObjects(scene.children,false);\r\n            //     // //把所有有children的屏蔽掉，可以防止对helper进行控制\r\n            //     // scene.add(transformControl);\r\n            //     // if(intersection.length){\r\n\r\n                    \r\n            //     //     const object=intersection[0].object;\r\n            //     //     transformControl.attach(object);\r\n            //     // }else{\r\n            //     //     //当点击到场景空白处时禁用可控件\r\n            //     //    transformControl.detach();\r\n            //     // }\r\n            // });\r\n\r\n        // },\r\n        initStats(){\r\n            stats = new Stats();\r\n             stats.domElement.style.position = 'absolute'; //绝对坐标  \r\n                stats.domElement.style.left = '0px';// (0,0)px,左上角  \r\n                stats.domElement.style.top = '0px';  \r\n            document.getElementById('webgl').appendChild(stats.domElement);\r\n\r\n        },\r\n        updatePosition(){\r\n            mesh.position.set(controls.positionX,controls.positionY,controls.positionZ);\r\n        },\r\n        //初始化渲染器\r\n        initRenderer(){\r\n            \r\n            \r\n            renderer=new THREE.WebGLRenderer({antialias:true});//实例化渲染器\r\n            //抗锯齿开启\r\n            renderer.setSize(window.innerWidth*0.7,window.innerHeight*0.7);//设置宽高\r\n            document.getElementById('webgl').appendChild(renderer.domElement);//添加到dom\r\n        },\r\n        //初始化场景\r\n        initScene(){\r\n            \r\n            scene=new THREE.Scene();//实例化场景\r\n            objs=[];\r\n             scene.background = new THREE.CubeTextureLoader().load([\r\n          require('@/assets/skybox/Galaxy/Right.jpg'),\r\n          require('@/assets/skybox/Galaxy/Left.jpg'),\r\n          require('@/assets/skybox/Galaxy/Up.jpg'),\r\n          require('@/assets/skybox/Galaxy/Down.jpg'),\r\n          require('@/assets/skybox/Galaxy/Front.jpg'),\r\n          require('@/assets/skybox/Galaxy/Back.jpg')\r\n        ]);\r\n            // this.$bus.$emit('sceneChanged',scene);\r\n        },\r\n        //初始化相机\r\n        initCamera(){\r\n            camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.1,200)\r\n            //实例化相机】\r\n            camera.position.set(0,0,150);\r\n        },\r\n        //创建模型\r\n        initMesh(){\r\n            // geometry = new THREE.BoxGeometry(5, 5, 5 ); //创建几何体\r\n            // var material=new THREE.MeshStandardMaterial();\r\n            // material.color=new Color(0.7,0.2,0.2); //创建材质\r\n\r\n            // mesh = new THREE.Mesh( geometry, material ); //创建网格\r\n            // mesh.name=\"盒子\";\r\n\r\n            // scene.add( mesh ); //将网格添加到场景\r\n            \r\n          \r\n            // this.initCone();\r\n            // this.initBox();\r\n            this.initLine();\r\n            this.initBars();\r\n\r\n        },\r\n\r\n        initBars(){\r\n            this.audioBars(25,128);\r\n        },\r\n\r\n        audioBars(radius, countData) {\r\n      let barGroup = new THREE.Group();\r\n      let R = radius;\r\n      let N = countData;\r\n      for (let i = 0; i < N; i++) {\r\n        let minGroup = new THREE.Group();\r\n        let box = new THREE.BoxGeometry(1, 1, 1);\r\n        let material = new THREE.MeshPhongMaterial({\r\n          color: 0x00ffff\r\n        }); // 材质对象\r\n        let m = i;\r\n        let mesh = new THREE.Mesh(box, material);\r\n\r\n        mesh.position.y = 0.5;\r\n        minGroup.add(mesh);\r\n        minGroup.position.set(\r\n          Math.sin(((m * Math.PI) / N) * 2) * R,\r\n          Math.cos(((m * Math.PI) / N) * 2) * R,\r\n          0\r\n        );\r\n       minGroup.rotation.z = ((-m * Math.PI) / N) * 2;\r\n        barGroup.add(minGroup);\r\n      }\r\n      barGroup.name=\"音频谱\";\r\n      barGroup.type=\"BarGroup\";\r\n      scene.add(barGroup);\r\n      objs.push(barGroup);\r\n    },\r\n/* 这里有个原理，为什么对音频线和音频组进行移动旋转操作后 依然可以根据初始化的音频数据进行重画\r\n按原理来说应该要重新计算各个线段的坐标值进行重绘，为什么这里导出数据后依然可以利用初始化的\r\nbarNodes进行一个线段计算重回吧，原因是因为，在编辑器中对一个组对象进行操作时，其各子对象\r\n的坐标并不会变化，只改变这个组对象的位置、旋转等信息，其子对象的坐标一直是相对于其父对象的\r\n坐标即本地坐标，而非世界坐标，只有当父对象是scene场景时，本地坐标才等于世界坐标\r\n */\r\n        initLine(){\r\n            this.audioLines(20,256);\r\n        },\r\n        renderGeometries(vertices) {\r\n            const res = [];\r\n            vertices = vertices.concat(vertices[0]);\r\n            //合并数组，把里外位置告知要画的线\r\n            vertices.forEach(value => {\r\n            res.push(value.x, value.y, 0);\r\n      });\r\n            return new THREE.BufferAttribute(new Float32Array(res), 3);\r\n    },\r\n        audioLines(radius, countData) {\r\n            var barNodes = range(0, countData).map(index => {\r\n                return new node(\r\n                radius,\r\n                ((index / countData) * 360 + 45) % 360,\r\n                new THREE.Vector2(0, 0)\r\n                );\r\n            });\r\n            //得到一个记录圆上256个点的位置信息的数组\r\n            const lineMaterial = new THREE.LineBasicMaterial({\r\n                color: 0x00ffff\r\n            });\r\n            var barLine = range(0, countData).map(index => {\r\n            return new THREE.Line(\r\n                new THREE.BufferGeometry().setAttribute(\r\n                    \"position\",\r\n                this.renderGeometries([\r\n                    barNodes[index].positionA(),\r\n                     barNodes[index].positionB()\r\n            ])\r\n          ),\r\n            lineMaterial\r\n            );\r\n        });\r\n        var outLine = new THREE.Line(\r\n        new THREE.BufferGeometry().setAttribute(\r\n          \"position\",\r\n          this.renderGeometries(barNodes.map(node => node.positionA()))\r\n        ),\r\n        lineMaterial\r\n      );\r\n\r\n      var inLine = new THREE.Line(\r\n        new THREE.BufferGeometry().setAttribute(\r\n          \"position\",\r\n          this.renderGeometries(barNodes.map(node => node.positionB()))\r\n        ),\r\n        lineMaterial\r\n      );\r\n\r\n      var linesGroup = new THREE.Group();\r\n      linesGroup.add(outLine);\r\n      linesGroup.add(inLine);\r\n      barLine.forEach(line => linesGroup.add(line));\r\n      linesGroup.name=\"音频线\";\r\n      linesGroup.type=\"LineGroup\";\r\n      scene.add(linesGroup);\r\n      objs.push(linesGroup);     \r\n    },\r\n\r\n\r\n\r\n        update(){\r\n            stats.update();\r\n        },\r\n        Reset(){\r\n          \r\n        },\r\n        ResetAll(){\r\n            this.$bus.$on('reset',()=>{\r\n                this.Reset();\r\n            });\r\n        },\r\n        Export(){\r\n            \r\n            this.$bus.$on('export',()=>{\r\n            if(scene.children.length>0){\r\n                let obj;\r\n                //删除所有helper，只保留光源、材质\r\n                for(var i=scene.children.length-1;i>=0;i--){\r\n                    \r\n                     obj=scene.children[i];\r\n                    if(obj.type.indexOf('Helper')!=-1||obj.type.indexOf('Control')!=-1){\r\n                         scene.remove(obj);\r\n                    }\r\n                }\r\n            }\r\n\r\n                //因为每次迭代中.children 一旦remove后从头开始执行\r\n                //数组会改变，因此使用遍历的forEach也好，traverse也好数组的\r\n                //索引全都改变，只会删除一个对象\r\n                //但如果从后开始遍历删除，每次remove后前面的索引也即是未遍历过的节点索引不会变\r\n                //使用state值然后进行深度监听依然不行，因为watch方法每次在mounted之后\r\n                //这就导致了如果mounted中的data值变化，我需要导出的数据还是原来数据，watch只会在之后\r\n                //发生作用。\r\n           \r\n            var JSONStr=JSON.stringify(scene.toJSON());\r\n            //console.log(JSONStr);\r\n            this.download(\"scene.json\",JSONStr);  \r\n            this.initHelper();\r\n            });\r\n        },\r\n        download(filename,text){\r\n            var pom=document.createElement('a');\r\n            pom.setAttribute('href','data:text/plain;charset=utf-8,'\r\n            +encodeURIComponent(text));\r\n            pom.setAttribute('download',filename);\r\n            if(document.createEvent){\r\n                var event=document.createEvent('MouseEvents');\r\n                event.initMouseEvent('click',true, false,\r\n                window,0,0,0,0,0,false,false,false,false,0,null);\r\n                pom.dispatchEvent(event);\r\n            }else{\r\n                pom.click();\r\n            }\r\n\r\n        },\r\n        //运行动画\r\n        animate(){\r\n            requestAnimationFrame(this.animate);//循环调用函数\r\n            \r\n            // mesh.rotation.x+=0.01;\r\n            // // //每帧网格模型沿x轴旋转0.01弧度\r\n            // mesh.rotation.y+=0.02;\r\n            // //每帧网格模型沿y轴旋转0.02弧度\r\n            // //stats.update();//更新性能检测框\r\n\r\n            this.update();\r\n            renderer.render(scene,camera);//渲染\r\n        }\r\n    },\r\n    mounted() {\r\n        this.init();\r\n        this.CheckFromTree();\r\n        this.findcurrentObj();\r\n        this.AddModel();\r\n        this.ResetAll();\r\n        this.Export();\r\n    },\r\n}\r\n</script>\r\n<style>\r\n #webgl {\r\n    height: 500px;\r\n  }\r\n.app-container{\r\n    background-color: #432d43;\r\n}\r\n</style>"]}]}